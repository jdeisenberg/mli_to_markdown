// Generated by BUCKLESCRIPT VERSION 5.0.2, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Refmt = require("bs-refmt/src/Refmt.bs.js");
var $$String = require("bs-platform/lib/js/string.js");

function toReason(s, implOrInterface) {
  var param = (
      implOrInterface ? Refmt.parseMLI : Refmt.parseML
    )(s.replace((/\\@/g), "@"));
  if (param.tag) {
    return "Error: " + param[0][1][/* message */0];
  } else {
    return (
              implOrInterface ? Refmt.printREI : Refmt.printRE
            )(param[0]);
  }
}

function countLeadingWhitespace(s) {
  var sansNewlines = s.replace((/^\n+/g), "");
  var sansLeading = sansNewlines.replace((/^\s+/), "");
  return /* tuple */[
          s.length - sansNewlines.length | 0,
          sansNewlines.length - sansLeading.length | 0,
          sansLeading
        ];
}

function addSpaces(n, str) {
  var spaces = $$String.make(n, /* " " */32);
  return $$Array.map((function (item) {
                  return spaces + item;
                }), str.split("\n")).join("\n");
}

function multiLineToRE(implOrInterface, s) {
  var match = countLeadingWhitespace(s);
  var result = toReason(match[2], implOrInterface).replace((/\n\n/g), "\n").trim() + "\n";
  if (result.startsWith("Error:")) {
    return "!!!" + (s + "!!!");
  } else {
    return $$String.make(match[0], /* "\n" */10) + addSpaces(match[1], result);
  }
}

function singleLineToRE(implOrInterface, s) {
  var result = toReason(s, implOrInterface).trim().replace((/;$/), "");
  if (result.startsWith("Error:")) {
    return "!!!" + (s + "!!!");
  } else {
    return result;
  }
}

exports.toReason = toReason;
exports.countLeadingWhitespace = countLeadingWhitespace;
exports.addSpaces = addSpaces;
exports.multiLineToRE = multiLineToRE;
exports.singleLineToRE = singleLineToRE;
/* Refmt Not a pure module */
